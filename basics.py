# -*- coding: utf-8 -*-
"""Basics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Tx54BUsKf69QxbiDo85KpfsNJoolxe8
"""

x=True
print(type(x))

print(type(x))
print("OVERWRITING VALUE X")
x = 'Welcome to 7 Days of Data Science'
print(type(x))

x = 3
print(x, type(x))

print(x)

print(x + 1)   # Addition
print(x - 1)   # Subtraction
print(x * 2)   # Multiplication
print(x ** 2)  # Exponentiation

print(2**5)

x += 1          # x = x + 1
print(x)
x *= 2          # x = x * 2
print(x)

y=2.5
print(type(y))
print(y,y+1,y*2,y**2)

#Booleans
#Python implements all of the usual operators for Boolean logic, but uses English words rather than symbols (&&, ||, etc.):

t, f = True, False
print(type(t))

x = True
print()

print(t and f) # Logical AND;
print(t or f)  # Logical OR;
print(not t)   # Logical NOT;
print(t != f)  # Logical XOR;

#Strings

welcome = 'welcome'
to = 'to'
kjsce = "kjsce" # Strings can use single quotes or double quotes
print(welcome, len(welcome))

greetings = welcome + ' ' + to + ' ' + kjsce + '!' # String concatenation
print(greetings)

# greetings = '{} {} {}'.format(welcome,to,kjsce+'!')
greetings = f'{welcome} {to} {kjsce}.'  # string formatting
print(greetings)

#String objects have a bunch of useful methods; for example:

s = "welcome to kjsce"
print(s.capitalize())  # Capitalize a string
print(s.upper())       # Convert a string to uppercase; prints "HELLO"
# print(s.replace('l', '(ell)'))  # Replace all instances of one substring with another
print('  world  '.strip())  # Strip leading and trailing whitespace

#Conditionals

x=0
if x>0:
  print("positive")
elif x<0:
  print("negative")

x=9
if x<0:
  print("positive")
else:
    print("negative")

x = 0
if x > 0:
  print('positive')
elif x < 0:
  print('negative')
else:
  print('zero')

score=60
result="fail" if score <50 else "pass"
print(result)

#Containers
#Python includes several built-in container types: lists, dictionaries, sets, and tuples.

#Lists
#A list is the Python equivalent of an array, but is resizeable and can contain elements of different types:

xs = [3, 1, 2.888, 'rahul']   # Create a list
# print(xs, xs[2])
print(xs[-2])     # Negative indices count from the end of the list; prints "2"

xs[2] = 'foo'    # Lists can contain elements of different types
print(xs)

xs.append('bar') # Add a new element to the end of the list
print(xs)

x = xs.pop()     # Remove and return the last element of the list
print(x, xs.pop)

nums = list(range(5))    # range is a built-in function that creates a list of integers
print(nums)         # Prints "[0, 1, 2, 3, 4]"
print(nums[2:4])    # Get a slice from index 2 to 4 (exclusive); prints "[2, 3]"
print(nums[2:])     # Get a slice from index 2 to the end; prints "[2, 3, 4]"
print(nums[:2])     # Get a slice from the start to index 2 (exclusive); prints "[0, 1]"
print(nums[:])      # Get a slice of the whole list; prints ["0, 1, 2, 3, 4]"
print(nums[:4])    # Slice indices can be negative; prints ["0, 1, 2, 3]"
nums[2:4] = [8, 9] # Assign a new sublist to a slice
print(nums)         # Prints "[0, 1, 8, 9, 4]"

animals = ['cat', 'dog', 'monkey']
for animal in animals:
    print(animal)

#If you want access to the index of each element within the body of a loop, use the built-in enumerate function:
animals = ['cat', 'dog', 'monkey']
for idx, animal in enumerate(animals):
    print('#{}: {}'.format(idx + 1, animal))

#List comprehensions:
#When programming, frequently we want to transform one type of data into another. As a simple example, consider the following code that computes square numbers:

nums = [0, 1, 2, 3, 4]
squares = []
for x in nums:
    squares.append(x ** 2)
print(squares)

#You can make this code simpler using a list comprehension:
nums = [0, 1, 2, 3, 4]
squares = [x ** 2 for x in nums]
print(squares)

#list comprehentions that also contain conditions
nums=[0,1,2,3,4]
even_squares=[x**2 for x in nums if x%2==0]
print(even_squares)

nums=[0,1,2,3,4]
even_squares=[x**2 for x in nums if x%3==0]
print(even_squares)

#Dictionaries
#A dictionary stores (key, value) pairs, similar to a Map in Java or an object in Javascript. You can use it like this:
d = {'cat': 'cute', 'dog': 'furry'}
print(d.keys(),d.values())  # Create a new dictionary with some data
print(d['dog'])       # Get an entry from a dictionary; prints "cute"
print('cat' in d)

d['fish'] = 'wet'    # Set an entry in a dictionary
print(d['fish'])      # Prints "wet"

print(d)

print(d.get('monkey', 'N/A'))  # Get an element with a default; prints "N/A"
print(d.get('fish', 'N/A'))    # Get an element with a default; prints "wet"

del d['fish']        # Remove an element from a dictionary
print(d.get('fish', 'N/A')) # "fish" is no longer a key; prints

d = {'person': 2, 'cat': 4, 'spider': 8}
for animal, legs in d.items():
    print('A {} has {} legs'.format(animal, legs))

#Dictionary comprehensions:
#These are similar to list comprehensions, but allow you to easily construct dictionaries. For example:
nums = [0, 1, 2, 3, 4]
even_num_to_square = {x: x ** 2 for x in nums if x % 2 == 0}
print(even_num_to_square)

#sets
#A set is an unordered collection of distinct elements. As a simple example, consider the following:

animals = {'cat', 'dog', 'cat', 'dog'}
animals_ls = ['cat', 'dog', 'cat', 'dog']

print(type(animals))
print(animals)
print(animals_ls)

print('cat' in animals)   # Check if an element is in a set; prints "True"
print('fish' in animals)  # prints "False"

animals.add('fish')      # Add an element to a set
print('fish' in animals)
print(len(animals))       # Number of elements in a set;

animals.add('cat')       # Adding an element that is already in the set does nothing
print(len(animals))
animals.remove('cat')    # Remove an element from a set
print(len(animals))

animals.add('cat')       # Adding an element that is already in the set does nothing
print(len(animals))
animals.remove('cat')    # Remove an element from a set
print(len(animals))

#Loops
#Loops: Iterating over a set has the same syntax as iterating over a list; however since sets are unordered, you cannot make assumptions about the order in which you visit the elements of the set

animals = {'cat', 'dog', 'fish'}
for idx, animal in enumerate(animals):
    print('#{}: {}'.format(idx + 1, animal))

#Set comprehensions: Like lists and dictionaries, we can easily construct sets using set comprehensions:
from math import sqrt
print({int(sqrt(x)) for x in range(30)})

#Tuples
#A tuple is an (immutable) ordered list of values. A tuple is in many ways similar to a list; one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot. Here is a trivial example:

d = {(x, x + 1): x for x in range(10)}  # Create a dictionary with tuple keys
t = (5, 6)       # Create a tuple
print(type(t))
print(d[t])
print(d[(1, 2)])

#Functions
#Python functions are defined using the def keyword. For example:
def sign(x):
    if x > 0:
        return 'positive'
    elif x < 0:
        return 'negative'
    else:
        return 'zero'

for x in [-1, 0, 1]:
    print(sign(x))

def greetings(location, loud=True):
    if loud:
        print('Welcome to {}!'.format(location.upper()))
    else:
        print('Welcome to {}!'.format(location))

greetings('kjsce')
greetings('kjsce', loud=False)

#Classes
#The syntax for defining classes in Python is straightforward:

class Greeter:

    # Constructor
    def __init__(self, location):
        self.location = location  # Create an instance variable

    # Instance method
    def greet(self, loud=True):
        if loud:
          print('Welcome to {}!'.format(self.location.upper()))
        else:
          print('Welcome to {}!'.format(self.location))

g = Greeter('kjsce')  # Construct an instance of the Greeter class
g.greet()            # Call an instance method; prints "Welcome to IIITH!"
g.greet(loud=False)   # Call an instance method; prints "Welcome to iiith!"